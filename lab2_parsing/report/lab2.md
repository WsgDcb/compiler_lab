# <center>编译原理实验二</center>

## <center>算术表达式语法分析器设计实现</center>

| 姓名 | 马浩宇 | 学号 | 19335154 |
| ---- | ------ | ---- | -------- |

## 一、实验目标

使用**LL1分析法**和**LR分析法**设计实现算数表达式的语法分析器。

- 算术表达式至少支持加减乘除以及括号操作，即（+，-，*，/，（））

## 二、设计过程

### 算术表达式文法

在设计语法分析式前首先需要确定表达式的文法，本次实验设计支持的操作符为+，-，*，/，（），操作数为非关键字标识符或者数字类型（整数、小数、科学计数法等等）。首先根据运算符优先级，分为3类不同的优先级，最高的是括号，其次为乘除，最低为加减，所以得到的算术表达式文法如下所示：
$$
\begin{aligned}
&E\rightarrow T|E\omega_0T \\
&T\rightarrow F|T\omega_1F \\
&F\rightarrow I|(E)
\end{aligned}
$$
其中I包括数字或者标识符，E为开始符号，$\omega_0$表示加减运算符，$\omega_1$表示乘除运算符。

### LL(1)分析法

左递归产生式会导致LL(1)分析法失效，所以为了使用LL(1)分析法实现语法分析器，需要先消除算式表达式文法中的左递归产生式，得到的新文法如下所示：
$$
\begin{aligned}
&E\rightarrow TE_1\ (1)\ \\
&E_1\rightarrow \omega_0TE_1\ (2)|\epsilon\ (3)\\
&T\rightarrow FT_1 \ (4)\\
&T_1\rightarrow \omega_1FT_1\ (5)|\epsilon\ (6)\\
&F\rightarrow I\ (7)|(E)\ (8)
\end{aligned}
$$
接下来根据文法求每个产生式的select集如下所示：
$$
\begin{aligned}
&select(①) = \{I,(\}\\
&select(②) = \{\omega_0\}\\
&select(③) = \{),\#\}\\
&select(④) = \{I,(\}\\
&select(⑤) = \{\omega_1\}\\
&select(⑥) = \{\omega_0,),\#\}\\
&select(⑦) = \{I\}\\
&select(⑧) = \{(\}
\end{aligned}
$$
根据求出的select集绘制LL(1)分析表如下所示：

![LL(1)](D:\course\2\compiler\lab2\report\LL(1).png)

<center><b>LL1分析表</b></center>

#### 程序设计

通过map<string,string>储存LL(1)分析表，提高查询速度，其中key储存的格式为xx!xx，叹号用来起到分割作用，前半部分表示当前弹出的栈顶符，右侧对应此时next(w)读到的字符，value储存的格式为对应产生式的右部，例如key为E!I，对应的value为TE'。为了方便读取，所以将$\omega_0$记为p，$\omega_1$记为q，E1记为A，T1记为B，I记为n。在查找LL1分析表时，可以先通过`map.find()`查找对应的（栈顶符，当前符）是否存在，即检查对应的LL1表中是否为空白，如果没有查找到对应的key，则说明LL1表中该位置为空白，所以进行报错。

除了LL1分析表外，还需要通过两个`vector<string>`VX、VT，来储存对应的非终结符和终结符。对应的数据结构设计如下图所示：

![ll1table](D:\course\2\compiler\lab2\report\ll1table.png)

整个LL(1)分析法的设计思路与课件上的流程图大体一致，如下所示：

<img src="D:\course\2\compiler\lab2\report\ll1流程.png" alt="ll1流程" style="zoom: 67%;" />

具体在实现细节上同样也是通过stack数据类型来实现，每次循环取出栈顶符，在识别到栈顶符为非终结符时，需要查找LL(1)分析表，首先需要对当前的（栈顶符，当前符）进行拼接，通过词法分析器得到的tokens中的标号来识别其种类，并组合成LL1_table的key的格式进行查表。当当前tokens的编号为（）、+、-、*、/、标识符、数字之外的类型时，也进行报错提示未识别的符号。在识别到栈顶符为终结符时，需要将当前符与栈顶符进行判断如果相同，则读取下一个当前符，如果不同则进行栈顶终结符与当前符不匹配的报错。直到读取到当前栈顶符为#且与当前符匹配时，表示该算术表达式符合文法的要求。

### LR分析法

左递归产生式不会导致LR分析法失效，但是LR分析法需要引进一个新的文法开始符号以保证开始符号不在任何产生式的右部，并对文法产生式进行标号如下所示：
$$
\begin{aligned}
&E'\rightarrow E\ (0) \\
&E\rightarrow T\ (1)|E\omega_0T \ (2)\\
&T\rightarrow F\ (3)|T\omega_1F \ (4)\\
&F\rightarrow I\ (5)|(E)\ (6)
\end{aligned}
$$
根据算术表达式文法得到识别LR分析过程所有活前缀的DFA如下所示：

<img src="D:\course\2\compiler\lab2\report\LR0.png" style="zoom:80%;" />

<center><b>LR活前缀DFA</b></center>

根据上面的DFA可以发现LR(0)分析法在上表状态I3,I4会产生移进规约冲突，因此该文发不是LR(0)文法，所以采用SLR(1)分析法进行语法分析器设计。其中在发生冲突的I3，I4状态只需要在识别到产生式左部非终结符的follow集中的元素时才进行规约，即$follow(E) = \{),\omega_0,\#\}$，其余的对应报错或移进操作，根据上表得到SLR(1)分析表如下所示：

![](D:\course\2\compiler\lab2\report\LR(0).png)

<center><b>SLR分析表</b></center>

#### 程序设计

在表的储存方面，通过一个`vector<map<string,string>>`来储存LR分析表，vector的标号就表明当前的状态对应的map，map的key表示当前符，map的value就对应需要进行的操作，如移进表示为’sxx‘，规约表示为‘rxx’，分别代表移进xx状态或者按照第xx个规约规则进行规约。与LL1分析法相同，为了读取方便，将$\omega_0$记为p，$\omega_1$记为q，E1记为A，T1记为B，I记为n。同样可以通过map的find函数来判断是否LR分析表中的对应位置是否为空白，如果为空白则进行报错。

除此之外还需要一个对应的规约规则表，通过一个`map<int,string>`来储存，其中key对应规约规则的标号，value为相对应的规约规则。

<img src="D:\course\2\compiler\lab2\report\LRtable.png" alt="LRtable" style="zoom:67%;" />

LR分析法的程序的实现思路逻辑也与课件上的流程图相似，如下所示：

<img src="D:\course\2\compiler\lab2\report\LR流程.png" style="zoom:67%;" />

具体实现细节方面，每次循环只进行一次移进或者规约操作，为了解决连续规约带来的问题，所以需要通过一个flag来表示当前循环的当前符是上个规约得到的符号还是需要从字符串中读取当前符。每次规约后将该flag进行标记，下次对规约得到的字符进行操作，每次移进后将该标号取消标记，表示下次需要进行操作的当前符是待读取字符串的字符。

每次循环从栈中读取栈顶状态，并根据当前字符判断需要进行的操作，如果为移进操作，则将需要移进的状态push进栈中，如果为规约状态则首先pop掉对应的状态，然后将当前符设置为规约的字符，然后对规约flag进行标记。同样如果待识别字符串有（）、/、+、-、*、标识符或数字之外的字符也会进行报错。

## 三、结果展示

测试为了测试到全部支持的字符串，所以采用的测试表达式为a+b*(c/d)-1，接下来首先展示对于理论对于该实验得到的分析表，LL1分析法和LR分析法分别对应的分析过程。

#### 分析过程

LL1分析过程如下表所示：

![LL1分析](D:\course\2\compiler\lab2\report\LL1分析.png)

LR分析过程如下表所示：

![LR分析](D:\course\2\compiler\lab2\report\LR分析.png)

从上面两个分析过程可以看出，本次实验中计算得到的LL(1)分析表和LR分析表均可以正确识别包括（）、+、-、*、/等符号的算术表达式。

#### 正确结果以及报错展示

对于上面的表达式其在两种语法分析器下的程序测试结果如下图所示：
![result1](D:\course\2\compiler\lab2\report\result1.png)

可以看到均可以识别正确，接下来检查几种设计的报错情况，当有可以被词法分析器支持却不被语法分析器支持的符号输入时：

![result2](D:\course\2\compiler\lab2\report\result2.png)

可以观察到两种分析法均可以识别到错误的输入，并在报错中对其位置进行提示，当有不符合表达式文法的表达出现时：

![result3](D:\course\2\compiler\lab2\report\result3.png)

会提示属于语法错误，分别对应的类型为栈顶终结符与当前符不匹配或者没有对应的文法规则。

## 四、心得及总结

通过这次实验首先是对上次的词法分析器进行了一定的完善与修改，将取负与减号的含义分开，负号只会出现在标识符、数字或者右括号的后面，所以通过词法分析器记录的前一状态的方法即可区分是负号还是减号，本次实验的算术表达式没有支持取负操作符。

本次实验总体来说设计思路并不复杂，因为只需要完成算术表达式的文法分析器，所以其对应的文法数量有限，并且较简单，具体代码的设计思路也只需要仿照课件上的流程图完成即可。碰到的问题大多集中在一开始写文法和绘制分析表的过程中，一开始仿照课件的LR分析表画法并没有取得很好地效果，于是查找了其他方式来绘制对应的LR分析表较为清晰简单，在选择表示分析表的数据结构时一开始没有通过map来实现，为后续的实现带来了不小的麻烦，所以最后采用了map的数据结构来方便后续代码的书写。

通过本次实验熟悉了基本的LL(1)语法分析器和LR语法分析器的设计流程，不仅与课上的知识相呼应加深了理解，也为后续的实验奠定了基础。

本次实验的完整代码见https://github.com/WsgDcb/compiler_lab/tree/master/lab。



